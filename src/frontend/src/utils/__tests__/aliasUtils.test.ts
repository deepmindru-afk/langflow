/**
 * Unit tests for alias utility functions
 */

import type { AllNodeType, GenericNodeType } from "@/types/flow";
import {
  assignAliasToNewComponent,
  clearUserDefinedAlias,
  generateAutoAlias,
  isSafeToModifyAlias,
  migrateExistingFlow,
  needsMigration,
  renumberAutoGeneratedAliases,
  setUserDefinedAlias,
  updateAliasesForDisplayNameChange,
} from "../aliasUtils";

// Helper function to create mock generic nodes
function createMockNode(
  id: string,
  displayName: string,
  alias?: string,
  aliasIsUserDefined = false,
): GenericNodeType {
  return {
    id,
    type: "genericNode",
    position: { x: 0, y: 0 },
    data: {
      showNode: true,
      type: "generic",
      id,
      node: {
        display_name: displayName,
        alias,
        alias_is_user_defined: aliasIsUserDefined,
        description: "",
        template: {},
        documentation: "",
      },
    },
  };
}

describe("Alias Service Utility Functions", () => {
  describe("isSafeToModifyAlias", () => {
    it("should return false for user-defined aliases", () => {
      const node = createMockNode("1", "OpenAI", "MyCustomLLM", true);
      expect(isSafeToModifyAlias(node)).toBe(false);
    });

    it("should return true for auto-generated aliases", () => {
      const node = createMockNode("1", "OpenAI", "OpenAI#1", false);
      expect(isSafeToModifyAlias(node)).toBe(true);
    });

    it("should return true for nodes without aliases", () => {
      const node = createMockNode("1", "OpenAI");
      expect(isSafeToModifyAlias(node)).toBe(true);
    });
  });

  describe("generateAutoAlias", () => {
    it("should generate first alias correctly", () => {
      const existingNodes: AllNodeType[] = [];
      const result = generateAutoAlias("OpenAI", existingNodes);
      expect(result).toBe("OpenAI#1");
    });

    it("should generate next available alias number", () => {
      const existingNodes: AllNodeType[] = [
        createMockNode("1", "OpenAI", "OpenAI#1"),
        createMockNode("2", "OpenAI", "OpenAI#2"),
      ];
      const result = generateAutoAlias("OpenAI", existingNodes);
      expect(result).toBe("OpenAI#3");
    });

    it("should fill gaps in numbering", () => {
      const existingNodes: AllNodeType[] = [
        createMockNode("1", "OpenAI", "OpenAI#1"),
        createMockNode("3", "OpenAI", "OpenAI#4"), // Gap at #2 and #3
      ];
      const result = generateAutoAlias("OpenAI", existingNodes);
      expect(result).toBe("OpenAI#2");
    });

    it("should ignore user-defined aliases when calculating numbers", () => {
      const existingNodes: AllNodeType[] = [
        createMockNode("1", "OpenAI", "OpenAI#1"),
        createMockNode("2", "OpenAI", "MyCustomLLM", true), // User-defined, should be ignored
        createMockNode("3", "OpenAI", "OpenAI#2"),
      ];
      const result = generateAutoAlias("OpenAI", existingNodes);
      expect(result).toBe("OpenAI#3");
    });
  });

  describe("assignAliasToNewComponent", () => {
    it("should not assign alias to first component of a type", () => {
      const newNode = createMockNode("1", "OpenAI");
      const existingNodes: AllNodeType[] = [];

      assignAliasToNewComponent(newNode, existingNodes);

      expect(newNode.data.node.alias).toBeUndefined();
      expect(newNode.data.node.alias_is_user_defined).toBe(false);
    });

    it("should assign aliases to both components when adding second", () => {
      const existingNode = createMockNode("1", "OpenAI");
      const newNode = createMockNode("2", "OpenAI");
      const existingNodes: AllNodeType[] = [existingNode];

      assignAliasToNewComponent(newNode, existingNodes);

      // First node should get alias
      expect(existingNode.data.node.alias).toBe("OpenAI#1");
      expect(existingNode.data.node.alias_is_user_defined).toBe(false);

      // New node should get alias
      expect(newNode.data.node.alias).toBe("OpenAI#2");
      expect(newNode.data.node.alias_is_user_defined).toBe(false);
    });

    it("should generate next available alias for third component", () => {
      const newNode = createMockNode("3", "OpenAI");
      const existingNodes: AllNodeType[] = [
        createMockNode("1", "OpenAI", "OpenAI#1"),
        createMockNode("2", "OpenAI", "OpenAI#2"),
      ];

      assignAliasToNewComponent(newNode, existingNodes);

      expect(newNode.data.node.alias).toBe("OpenAI#3");
      expect(newNode.data.node.alias_is_user_defined).toBe(false);
    });

    it("should not affect different component types", () => {
      const newNode = createMockNode("2", "Wikipedia");
      const existingNodes: AllNodeType[] = [
        createMockNode("1", "OpenAI", "OpenAI#1"),
      ];

      assignAliasToNewComponent(newNode, existingNodes);

      expect(newNode.data.node.alias).toBeUndefined();
      // Existing node should remain unchanged
      expect(existingNodes[0].data.node.alias).toBe("OpenAI#1");
    });
  });

  describe("migrateExistingFlow", () => {
    it("should not modify single components", () => {
      const nodes: AllNodeType[] = [
        createMockNode("1", "OpenAI"),
        createMockNode("2", "Wikipedia"),
      ];

      const result = migrateExistingFlow(nodes);

      expect(result[0].data.node.alias).toBeUndefined();
      expect(result[1].data.node.alias).toBeUndefined();
    });

    it("should assign aliases to duplicate components without aliases", () => {
      const nodes: AllNodeType[] = [
        createMockNode("1", "OpenAI"),
        createMockNode("2", "OpenAI"),
        createMockNode("3", "OpenAI"),
      ];

      const result = migrateExistingFlow(nodes);

      expect(result[0].data.node.alias).toBe("OpenAI#1");
      expect(result[1].data.node.alias).toBe("OpenAI#2");
      expect(result[2].data.node.alias).toBe("OpenAI#3");
      expect(result[0].data.node.alias_is_user_defined).toBe(false);
      expect(result[1].data.node.alias_is_user_defined).toBe(false);
      expect(result[2].data.node.alias_is_user_defined).toBe(false);
    });

    it("should preserve existing valid aliases", () => {
      const nodes: AllNodeType[] = [
        createMockNode("1", "OpenAI", "OpenAI#1"), // Already has valid alias
        createMockNode("2", "OpenAI"), // No alias
        createMockNode("3", "OpenAI"), // No alias
      ];

      const result = migrateExistingFlow(nodes);

      expect(result[0].data.node.alias).toBe("OpenAI#1"); // Preserved
      expect(result[1].data.node.alias).toBe("OpenAI#2"); // New
      expect(result[2].data.node.alias).toBe("OpenAI#3"); // New
    });

    it("should preserve user-defined aliases", () => {
      const nodes: AllNodeType[] = [
        createMockNode("1", "OpenAI", "MyCustomLLM", true), // User-defined
        createMockNode("2", "OpenAI"), // No alias
        createMockNode("3", "OpenAI"), // No alias
      ];

      const result = migrateExistingFlow(nodes);

      expect(result[0].data.node.alias).toBe("MyCustomLLM"); // Preserved
      expect(result[1].data.node.alias).toBe("OpenAI#1"); // New (starts from 1)
      expect(result[2].data.node.alias).toBe("OpenAI#2"); // New
    });

    it("should fix duplicate aliases", () => {
      const nodes: AllNodeType[] = [
        createMockNode("1", "OpenAI", "OpenAI#1"), // Valid
        createMockNode("2", "OpenAI", "OpenAI#1"), // Duplicate!
        createMockNode("3", "OpenAI"), // No alias
      ];

      const result = migrateExistingFlow(nodes);

      const aliases = result.map((n) => n.data.node.alias);
      expect(aliases).toEqual(["OpenAI#1", "OpenAI#2", "OpenAI#3"]);

      // Should be unique
      expect(new Set(aliases).size).toBe(3);
    });

    it("should handle mixed valid and invalid aliases", () => {
      const nodes: AllNodeType[] = [
        createMockNode("1", "OpenAI", "OpenAI#1"), // Valid
        createMockNode("2", "OpenAI", "SomeOldAlias"), // Invalid format
        createMockNode("3", "OpenAI", "OpenAI#5"), // Valid but high number
        createMockNode("4", "OpenAI"), // No alias
      ];

      const result = migrateExistingFlow(nodes);

      expect(result[0].data.node.alias).toBe("OpenAI#1"); // Preserved
      expect(result[1].data.node.alias).toBe("OpenAI#2"); // Reassigned (was invalid)
      expect(result[2].data.node.alias).toBe("OpenAI#5"); // Preserved (valid auto-generated)
      expect(result[3].data.node.alias).toBe("OpenAI#3"); // New (fills gap)
    });
  });

  describe("needsMigration", () => {
    it("should return false for single components", () => {
      const nodes: AllNodeType[] = [
        createMockNode("1", "OpenAI"),
        createMockNode("2", "Wikipedia"),
      ];

      expect(needsMigration(nodes)).toBe(false);
    });

    it("should return false for properly aliased duplicates", () => {
      const nodes: AllNodeType[] = [
        createMockNode("1", "OpenAI", "OpenAI#1"),
        createMockNode("2", "OpenAI", "OpenAI#2"),
        createMockNode("3", "OpenAI", "MyCustomLLM", true),
      ];

      expect(needsMigration(nodes)).toBe(false);
    });

    it("should return true for duplicates without aliases", () => {
      const nodes: AllNodeType[] = [
        createMockNode("1", "OpenAI"),
        createMockNode("2", "OpenAI"),
      ];

      expect(needsMigration(nodes)).toBe(true);
    });

    it("should return true for duplicates with invalid aliases", () => {
      const nodes: AllNodeType[] = [
        createMockNode("1", "OpenAI", "OpenAI#1"),
        createMockNode("2", "OpenAI", "InvalidAlias"), // Wrong format
      ];

      expect(needsMigration(nodes)).toBe(true);
    });

    it("should return true for duplicate alias conflicts", () => {
      const nodes: AllNodeType[] = [
        createMockNode("1", "OpenAI", "OpenAI#1"),
        createMockNode("2", "OpenAI", "OpenAI#1"), // Duplicate!
      ];

      expect(needsMigration(nodes)).toBe(true);
    });
  });

  describe("renumberAutoGeneratedAliases", () => {
    it("should renumber auto-generated aliases to fill gaps", () => {
      const nodes: AllNodeType[] = [
        createMockNode("1", "OpenAI", "OpenAI#1"), // Will become #1
        createMockNode("3", "OpenAI", "OpenAI#4"), // Will become #2
      ];

      const result = renumberAutoGeneratedAliases(nodes, "OpenAI");

      const openAINodes = result.filter(
        (n) =>
          n.type === "genericNode" && n.data.node.display_name === "OpenAI",
      );
      expect(openAINodes[0].data.node.alias).toBe("OpenAI#1");
      expect(openAINodes[1].data.node.alias).toBe("OpenAI#2");
    });

    it("should preserve user-defined aliases during renumbering", () => {
      const nodes: AllNodeType[] = [
        createMockNode("1", "OpenAI", "MyCustomLLM", true), // User-defined, preserve
        createMockNode("2", "OpenAI", "OpenAI#3"), // Auto-generated, will renumber
        createMockNode("3", "OpenAI", "OpenAI#5"), // Auto-generated, will renumber
      ];

      const result = renumberAutoGeneratedAliases(nodes, "OpenAI");

      const openAINodes = result.filter(
        (n) =>
          n.type === "genericNode" && n.data.node.display_name === "OpenAI",
      );

      // Find nodes by their original IDs to check transformation
      const node1 = result.find((n) => n.id === "1")!;
      const node2 = result.find((n) => n.id === "2")!;
      const node3 = result.find((n) => n.id === "3")!;

      expect(node1.data.node.alias).toBe("MyCustomLLM"); // Preserved
      expect(node2.data.node.alias).toBe("OpenAI#1"); // Renumbered
      expect(node3.data.node.alias).toBe("OpenAI#2"); // Renumbered
    });
  });

  describe("setUserDefinedAlias", () => {
    it("should set custom alias and mark as user-defined", () => {
      const node = createMockNode("1", "OpenAI", "OpenAI#1");
      const nodes: AllNodeType[] = [node];

      setUserDefinedAlias("1", "MyProductionLLM", nodes);

      expect(node.data.node.alias).toBe("MyProductionLLM");
      expect(node.data.node.alias_is_user_defined).toBe(true);
    });

    it("should handle node not found gracefully", () => {
      const nodes: AllNodeType[] = [createMockNode("1", "OpenAI", "OpenAI#1")];

      // Should not throw error
      expect(() => {
        setUserDefinedAlias("nonexistent", "CustomAlias", nodes);
      }).not.toThrow();
    });
  });

  describe("clearUserDefinedAlias", () => {
    it("should revert user-defined alias to auto-generated", () => {
      const node = createMockNode("1", "OpenAI", "MyCustomLLM", true);
      const nodes: AllNodeType[] = [
        node,
        createMockNode("2", "OpenAI", "OpenAI#2"),
      ];

      clearUserDefinedAlias("1", nodes);

      expect(node.data.node.alias).toBe("OpenAI#1"); // Generated new auto-alias
      expect(node.data.node.alias_is_user_defined).toBe(false);
    });

    it("should not clear already auto-generated aliases", () => {
      const node = createMockNode("1", "OpenAI", "OpenAI#1", false);
      const nodes: AllNodeType[] = [node];

      // Mock console.warn to capture warning
      const consoleSpy = jest.spyOn(console, "warn").mockImplementation();

      clearUserDefinedAlias("1", nodes);

      expect(consoleSpy).toHaveBeenCalledWith(
        "Cannot clear user-defined alias for node 1: already auto-generated",
      );
      expect(node.data.node.alias).toBe("OpenAI#1"); // Unchanged

      consoleSpy.mockRestore();
    });
  });

  describe("updateAliasesForDisplayNameChange", () => {
    it("should update auto-generated alias when display name changes", () => {
      const targetNode = createMockNode("1", "OpenAI", "OpenAI#1");
      const nodes: AllNodeType[] = [targetNode];

      const result = updateAliasesForDisplayNameChange(
        "1",
        "OpenAI",
        "ResponseGenerator",
        nodes,
      );

      const updatedNode = result.find((n) => n.id === "1")!;
      expect(updatedNode.data.node.alias).toBeUndefined(); // Single component, no alias needed
    });

    it("should not update user-defined aliases", () => {
      const targetNode = createMockNode("1", "OpenAI", "MyCustomLLM", true);
      const nodes: AllNodeType[] = [targetNode];

      const consoleSpy = jest.spyOn(console, "warn").mockImplementation();

      const result = updateAliasesForDisplayNameChange(
        "1",
        "OpenAI",
        "ResponseGenerator",
        nodes,
      );

      expect(consoleSpy).toHaveBeenCalledWith(
        "Cannot update alias for node 1: user-defined alias must be preserved",
      );
      expect(targetNode.data.node.alias).toBe("MyCustomLLM"); // Unchanged

      consoleSpy.mockRestore();
    });
  });

  describe("Integration Tests", () => {
    it("should handle complete workflow: migration + new component + renaming", () => {
      // Step 1: Start with existing flow (migration scenario)
      let nodes: AllNodeType[] = [
        createMockNode("1", "Language Model"), // No alias
        createMockNode("2", "Language Model", "Language Model#1"), // Has alias
        createMockNode("3", "Language Model"), // No alias
      ];

      // Migrate existing flow
      nodes = migrateExistingFlow(nodes);

      // Check migration results - order depends on how migration assigns them
      const aliasedNodes = nodes.filter((n) => n.data.node.alias);
      const aliases = aliasedNodes.map((n) => n.data.node.alias).sort();
      expect(aliases).toEqual([
        "Language Model#1",
        "Language Model#2",
        "Language Model#3",
      ]);

      // Step 2: Add new component
      const newNode = createMockNode("4", "Language Model");
      assignAliasToNewComponent(newNode, nodes);
      nodes.push(newNode);

      expect(newNode.data.node.alias).toBe("Language Model#4"); // Next available

      // Step 3: User customizes one alias
      setUserDefinedAlias("2", "MySpecialModel", nodes);

      expect(nodes[1].data.node.alias).toBe("MySpecialModel");
      expect(nodes[1].data.node.alias_is_user_defined).toBe(true);

      // Step 4: Remove a component and renumber
      const remainingNodes = nodes.filter((n) => n.id !== "1");
      renumberAutoGeneratedAliases(remainingNodes, "Language Model");

      const languageModelNodes = remainingNodes.filter(
        (n) =>
          n.type === "genericNode" &&
          n.data.node.display_name === "Language Model",
      );

      // User-defined alias should be preserved
      const customNode = languageModelNodes.find(
        (n) => n.data.node.alias === "MySpecialModel",
      );
      expect(customNode).toBeDefined();
      expect(customNode!.data.node.alias_is_user_defined).toBe(true);

      // Auto-generated aliases should be renumbered
      const autoNodes = languageModelNodes.filter(
        (n) => !n.data.node.alias_is_user_defined,
      );
      expect(autoNodes.map((n) => n.data.node.alias)).toEqual([
        "Language Model#1",
        "Language Model#2",
      ]);
    });

    it("should maintain unique aliases across all operations", () => {
      let nodes: AllNodeType[] = [
        createMockNode("1", "OpenAI"),
        createMockNode("2", "OpenAI"),
        createMockNode("3", "Wikipedia"),
        createMockNode("4", "Wikipedia"),
      ];

      // Migrate
      nodes = migrateExistingFlow(nodes);

      // Add more components
      const newOpenAI = createMockNode("5", "OpenAI");
      const newWikipedia = createMockNode("6", "Wikipedia");

      assignAliasToNewComponent(newOpenAI, nodes);
      assignAliasToNewComponent(newWikipedia, nodes);

      nodes.push(newOpenAI, newWikipedia);

      // Collect all aliases
      const allAliases = nodes
        .filter((n) => n.type === "genericNode" && n.data.node.alias)
        .map((n) => n.data.node.alias);

      // All aliases should be unique
      expect(new Set(allAliases).size).toBe(allAliases.length);

      // Should have proper numbering
      const openAIAliases = allAliases.filter((alias) =>
        alias?.startsWith("OpenAI#"),
      );
      const wikipediaAliases = allAliases.filter((alias) =>
        alias?.startsWith("Wikipedia#"),
      );

      expect(openAIAliases.sort()).toEqual([
        "OpenAI#1",
        "OpenAI#2",
        "OpenAI#3",
      ]);
      expect(wikipediaAliases.sort()).toEqual([
        "Wikipedia#1",
        "Wikipedia#2",
        "Wikipedia#3",
      ]);
    });

    it("should handle edge case: component with wrong display name in alias", () => {
      const nodes: AllNodeType[] = [
        createMockNode("1", "ResponseGenerator", "OpenAI#1"), // Wrong display name in alias
        createMockNode("2", "ResponseGenerator"), // No alias
      ];

      const result = migrateExistingFlow(nodes);

      // Should reassign invalid alias
      expect(result[0].data.node.alias).toBe("ResponseGenerator#1");
      expect(result[1].data.node.alias).toBe("ResponseGenerator#2");
    });

    it("should handle Unicode characters in display names", () => {
      const nodes: AllNodeType[] = [
        createMockNode("1", "测试组件"),
        createMockNode("2", "测试组件"),
      ];

      const result = migrateExistingFlow(nodes);

      expect(result[0].data.node.alias).toBe("测试组件#1");
      expect(result[1].data.node.alias).toBe("测试组件#2");
    });

    it("should handle special characters in display names", () => {
      const nodes: AllNodeType[] = [
        createMockNode("1", "Model (v2.0)"),
        createMockNode("2", "Model (v2.0)"),
      ];

      const result = migrateExistingFlow(nodes);

      expect(result[0].data.node.alias).toBe("Model (v2.0)#1");
      expect(result[1].data.node.alias).toBe("Model (v2.0)#2");
    });
  });

  describe("Safety and Error Handling", () => {
    it("should log warnings when attempting to modify protected aliases", () => {
      const node = createMockNode("1", "OpenAI", "MyCustomLLM", true);
      const nodes = [node, createMockNode("2", "OpenAI")];

      const consoleSpy = jest.spyOn(console, "warn").mockImplementation();

      // This should trigger a warning during renumbering
      const mockNodes = [...nodes];
      // Simulate trying to renumber (shouldn't affect user-defined)
      renumberAutoGeneratedAliases(mockNodes, "OpenAI");

      // User-defined alias should remain unchanged
      expect(mockNodes[0].data.node.alias).toBe("MyCustomLLM");
      expect(mockNodes[0].data.node.alias_is_user_defined).toBe(true);

      consoleSpy.mockRestore();
    });

    it("should handle empty node arrays gracefully", () => {
      expect(() => {
        migrateExistingFlow([]);
        needsMigration([]);
        renumberAutoGeneratedAliases([], "OpenAI");
      }).not.toThrow();
    });

    it("should handle nodes without proper data structure", () => {
      const malformedNode = {
        id: "1",
        type: "genericNode" as const,
        position: { x: 0, y: 0 },
        data: {
          // Missing node property
        },
      };

      expect(() => {
        migrateExistingFlow([malformedNode as any]);
      }).not.toThrow();
    });
  });
});
