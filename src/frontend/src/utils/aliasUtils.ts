import type { AllNodeType, GenericNodeType } from "@/types/flow";

/**
 * Utility functions for managing component aliases with hybrid approach:
 * - Auto-generated aliases renumber with gap-filling when components are removed
 * - User-defined aliases remain stable to preserve semantic meaning
 *
 * CRITICAL SAFETY RULES:
 * 1. NEVER modify user-defined aliases (alias_is_user_defined: true)
 * 2. NEVER change existing valid aliases during migration unless duplicates exist
 * 3. ONLY reassign auto-generated aliases or components without aliases
 * 4. ALWAYS preserve user semantic meaning in custom aliases
 */

/**
 * Safety check: Verify if it's safe to modify a component's alias
 * @param node The node to check
 * @returns true if safe to modify, false if alias must be preserved
 */
export function isSafeToModifyAlias(node: GenericNodeType): boolean {
  // NEVER modify user-defined aliases
  if (node.data.node.alias_is_user_defined) {
    return false;
  }

  // Safe to modify if no alias or auto-generated
  return true;
}

/**
 * Generate auto-alias with gap-filling for components of the same display_name
 */
export function generateAutoAlias(
  displayName: string,
  existingNodes: AllNodeType[],
): string {
  const sameTypeNodes = getNodesByDisplayName(existingNodes, displayName);
  const autoGenerated = sameTypeNodes.filter(
    (n) => n.type === "genericNode" && !n.data.node.alias_is_user_defined,
  );

  // Find the lowest available number
  let counter = 1;
  const usedNumbers = new Set<number>();

  // Collect used numbers from auto-generated aliases only
  autoGenerated.forEach((node) => {
    if (node.type === "genericNode" && node.data.node.alias) {
      const match = node.data.node.alias.match(/^.+#(\d+)$/);
      if (match) usedNumbers.add(parseInt(match[1]));
    }
  });

  // Find first available slot
  while (usedNumbers.has(counter)) {
    counter++;
  }

  return `${displayName}#${counter}`;
}

/**
 * Renumber auto-generated aliases when component is removed (hybrid approach)
 */
export function renumberAutoGeneratedAliases(
  nodes: AllNodeType[],
  removedDisplayName: string,
): AllNodeType[] {
  const sameTypeNodes = getNodesByDisplayName(nodes, removedDisplayName)
    .filter(
      (n) => n.type === "genericNode" && !n.data.node.alias_is_user_defined,
    ) // Only auto-generated
    .sort((a, b) => {
      const numA = extractNumber(
        a.type === "genericNode" ? a.data.node.alias : null,
      );
      const numB = extractNumber(
        b.type === "genericNode" ? b.data.node.alias : null,
      );
      return numA - numB;
    });

  // Renumber to fill gaps: #1, #2, #3, etc.
  sameTypeNodes.forEach((node, index) => {
    if (node.type === "genericNode" && isSafeToModifyAlias(node)) {
      const newAlias = `${removedDisplayName}#${index + 1}`;
      node.data.node.alias = newAlias;
    }
  });

  return nodes;
}

/**
 * Assign aliases when adding a new component to workspace
 */
export function assignAliasToNewComponent(
  newNode: AllNodeType,
  existingNodes: AllNodeType[],
): void {
  if (newNode.type !== "genericNode") return;

  const displayName = newNode.data.node.display_name;
  const sameTypeNodes = existingNodes.filter(
    (n) => n.type === "genericNode" && n.data.node.display_name === displayName,
  );

  if (sameTypeNodes.length === 0) {
    // First of its type - no alias needed initially
    newNode.data.node.alias = undefined;
    newNode.data.node.alias_is_user_defined = false;
  } else if (sameTypeNodes.length === 1 && !sameTypeNodes[0].data.node.alias) {
    // Second of its type - assign aliases to both
    const firstNode = sameTypeNodes[0] as GenericNodeType;
    firstNode.data.node.alias = `${displayName}#1`;
    firstNode.data.node.alias_is_user_defined = false;

    newNode.data.node.alias = `${displayName}#2`;
    newNode.data.node.alias_is_user_defined = false;
  } else {
    // Multiple exist - generate next available auto-alias
    newNode.data.node.alias = generateAutoAlias(displayName, existingNodes);
    newNode.data.node.alias_is_user_defined = false;
  }
}

/**
 * Update aliases when display name changes
 */
export function updateAliasesForDisplayNameChange(
  nodeId: string,
  oldDisplayName: string,
  newDisplayName: string,
  allNodes: AllNodeType[],
): AllNodeType[] {
  const targetNode = allNodes.find((n) => n.id === nodeId);
  if (!targetNode || targetNode.type !== "genericNode") return allNodes;

  // SAFETY CHECK: If this component has a user-defined alias, don't change it
  if (!isSafeToModifyAlias(targetNode)) {
    console.warn(
      `Cannot update alias for node ${nodeId}: user-defined alias must be preserved`,
    );
    return allNodes;
  }

  // Update auto-generated alias to use new display name
  const sameNewTypeNodes = allNodes.filter(
    (n) =>
      n.type === "genericNode" &&
      n.data.node.display_name === newDisplayName &&
      n.id !== nodeId,
  );

  if (sameNewTypeNodes.length === 0) {
    // Only component with this display name - remove alias
    targetNode.data.node.alias = undefined;
  } else {
    // Generate new alias based on new display name
    targetNode.data.node.alias = generateAutoAlias(newDisplayName, allNodes);
  }

  // Renumber any remaining components with the old display name
  renumberAutoGeneratedAliases(allNodes, oldDisplayName);

  return allNodes;
}

/**
 * Set user-defined alias
 */
export function setUserDefinedAlias(
  nodeId: string,
  customAlias: string,
  allNodes: AllNodeType[],
): void {
  const node = allNodes.find((n) => n.id === nodeId);
  if (!node || node.type !== "genericNode") return;

  const previousAlias = node.data.node.alias;
  const wasUserDefined = node.data.node.alias_is_user_defined;

  // Set custom alias
  node.data.node.alias = customAlias;
  node.data.node.alias_is_user_defined = true;

  // Trigger renumbering of remaining auto-generated aliases if needed
  if (previousAlias && !wasUserDefined) {
    renumberAutoGeneratedAliases(allNodes, node.data.node.display_name);
  }
}

/**
 * Clear user-defined alias (revert to auto-generated)
 */
export function clearUserDefinedAlias(
  nodeId: string,
  allNodes: AllNodeType[],
): void {
  const node = allNodes.find((n) => n.id === nodeId);
  if (!node || node.type !== "genericNode") return;

  // SAFETY CHECK: Only clear if it's actually user-defined
  if (!node.data.node.alias_is_user_defined) {
    console.warn(
      `Cannot clear user-defined alias for node ${nodeId}: already auto-generated`,
    );
    return;
  }

  node.data.node.alias_is_user_defined = false;

  // Generate new auto-alias based on existing nodes
  node.data.node.alias = generateAutoAlias(
    node.data.node.display_name,
    allNodes,
  );
}

/**
 * Migrate existing flows to assign aliases to duplicate components
 * This ensures backward compatibility for flows created before alias implementation
 */
export function migrateExistingFlow(nodes: AllNodeType[]): AllNodeType[] {
  // Group nodes by display_name
  const nodesByDisplayName = new Map<string, GenericNodeType[]>();

  nodes.forEach((node) => {
    if (node.type === "genericNode" && node.data?.node?.display_name) {
      const displayName = node.data.node.display_name;
      if (!nodesByDisplayName.has(displayName)) {
        nodesByDisplayName.set(displayName, []);
      }
      nodesByDisplayName.get(displayName)!.push(node);
    }
  });

  // Assign aliases to groups with multiple components
  nodesByDisplayName.forEach((sameTypeNodes, displayName) => {
    if (sameTypeNodes.length > 1) {
      // Separate user-defined from auto-generated aliases
      const userDefinedNodes: GenericNodeType[] = [];
      const autoGeneratedNodes: GenericNodeType[] = [];
      const usedNumbers = new Set<number>();

      // First pass: preserve valid aliases (both user-defined and valid auto-generated) and collect used numbers
      sameTypeNodes.forEach((node) => {
        const currentAlias = node.data.node.alias;
        const isUserDefined = node.data.node.alias_is_user_defined;

        if (currentAlias) {
          // Check if alias is valid format for this display name
          const match = currentAlias.match(
            new RegExp(
              `^${displayName.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}#(\\d+)$`,
            ),
          );

          if (isUserDefined) {
            // Always preserve user-defined aliases
            userDefinedNodes.push(node);
            if (match) {
              usedNumbers.add(parseInt(match[1]));
            }
          } else if (match) {
            // Valid auto-generated alias - preserve it too
            usedNumbers.add(parseInt(match[1]));
          } else {
            // Invalid auto-generated alias - needs reassignment
            autoGeneratedNodes.push(node);
          }
        } else {
          // No alias - needs one
          autoGeneratedNodes.push(node);
        }
      });

      // Second pass: reassign all auto-generated aliases to fill gaps
      let counter = 1;
      autoGeneratedNodes.forEach((node) => {
        // SAFETY CHECK: Only modify if safe
        if (!isSafeToModifyAlias(node)) {
          console.warn(
            `Attempted to modify protected alias for node ${node.id}. Skipping.`,
          );
          return;
        }

        // Find next available number
        while (usedNumbers.has(counter)) {
          counter++;
        }

        node.data.node.alias = `${displayName}#${counter}`;
        node.data.node.alias_is_user_defined = false;
        usedNumbers.add(counter);
        counter++;
      });
    } else {
      // Single component - ensure no alias if it's auto-generated
      const node = sameTypeNodes[0];
      if (node.data.node.alias && this.isSafeToModifyAlias(node)) {
        node.data.node.alias = undefined;
      }
    }
  });

  return nodes;
}

/**
 * Check if a flow needs migration (has duplicate components without proper aliases)
 */
export function needsMigration(nodes: AllNodeType[]): boolean {
  const nodesByDisplayName = new Map<string, GenericNodeType[]>();

  // Group nodes by display_name
  nodes.forEach((node) => {
    if (node.type === "genericNode" && node.data?.node?.display_name) {
      const displayName = node.data.node.display_name;
      if (!nodesByDisplayName.has(displayName)) {
        nodesByDisplayName.set(displayName, []);
      }
      nodesByDisplayName.get(displayName)!.push(node);
    }
  });

  // Check each group for migration needs
  for (const [displayName, sameTypeNodes] of nodesByDisplayName) {
    if (sameTypeNodes.length > 1) {
      // Check if any node lacks a valid alias or has duplicate aliases
      const aliases = new Set<string>();
      let requiresMigration = false;

      for (const node of sameTypeNodes) {
        const currentAlias = node.data.node.alias;

        if (!currentAlias) {
          requiresMigration = true; // No alias
          break;
        }

        // Check if alias is valid format for this display name
        const match = currentAlias.match(
          new RegExp(
            `^${displayName.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}#(\\d+)$`,
          ),
        );
        if (!match) {
          requiresMigration = true; // Invalid format
          break;
        }

        // Check for duplicates
        if (aliases.has(currentAlias)) {
          requiresMigration = true; // Duplicate alias
          break;
        }

        aliases.add(currentAlias);
      }

      if (requiresMigration) {
        return true;
      }
    }
  }

  return false;
}

// Helper functions
function extractNumber(alias: string | undefined): number {
  if (!alias) return 0;
  const match = alias.match(/^.+#(\d+)$/);
  return match ? parseInt(match[1]) : 0;
}

function getNodesByDisplayName(
  nodes: AllNodeType[],
  displayName: string,
): AllNodeType[] {
  return nodes.filter(
    (n) => n.type === "genericNode" && n.data.node.display_name === displayName,
  );
}
